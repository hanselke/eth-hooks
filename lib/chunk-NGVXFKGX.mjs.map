{"version":3,"sources":["../src/models/constants/common.ts","../src/models/constants/keyNamespace.ts","../src/models/contractTypes.ts","../src/models/hookTypes.ts","../src/models/contractTypesForge.ts","../src/models/contractTypesHardhat.ts"],"names":["z"],"mappings":"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","sourcesContent":["export const const_web3DialogClosedByUser = 'Modal closed by user';\nexport const const_web3DialogUserRejected = 'Error: User Rejected';\n","export const keyNamespace = {\n  network: 'network',\n  signer: 'signer',\n  contracts: 'contracts',\n  state: 'state',\n} as const;\n","import { z, ZodType } from 'zod';\n\n// /**\n//  * #### Summary\n//  * Zod Schema for {@link TBasicContract}\n//  */\n// export const basicContractSchema = z.object({\n//   address: z.string(),\n//   abi: z.array(z.any()).optional(),\n// });\n\n/**\n * #### Summary\n * Describes the basic structure of each contract\n *\n * @category Models\n */\nexport type TBasicContract = {\n  contractName: string;\n  address: string;\n  abi?: Readonly<Record<string, any>[]>;\n};\n\n/**\n * #### Summary\n * Describes a basic contract data record.\n * A record of key:chainId.  value:{address, chainId}\n * @category Models\n */\nexport type TBasicContractDeployment = {\n  [chainId: number]: {\n    chainId: number;\n    address: string;\n  };\n};\n\n// /**\n//  * #### Summary\n//  * Zod Schema for {@link TBasicContractConfig}\n//  */\n// export const basicContractConfigSchema = z.record(\n//   z.number({ description: 'chainId' }),\n//   z.object({\n//     address: z.string(),\n//     chainId: z.number(),\n//   })\n// );\n\n/**\n * #### Summary\n * Contracts by contract name\n * - A record key: contractNames, values: {@link TBasicContractDeployment}\n */\nexport type TContractDeploymentMap = {\n  [contractName: string]: {\n    config: TBasicContractDeployment;\n  };\n};\n/**\n * #### Summary\n * Zod Schema for {@link TContractDeploymentMap}\n */\nexport const contractDeploymentMapSchema: ZodType<TContractDeploymentMap> = z.record(\n  z.string({ description: 'contractName' }),\n  z.object({\n    config: z.record(\n      z.number({ description: 'chainId' }),\n      z.object({\n        address: z.string(),\n        chainId: z.number(),\n      })\n    ),\n  })\n);\n\n/**\n * #### Summary\n * Contracts by contract name, used by eth-hooks to connect and load contracts\n * - A record of key:{contract names}, values: Hardhat contract json\n * - includes chain id\n */\n\nexport type TContractMapWithAbi = {\n  [contractName: string]: {\n    config: TBasicContractDeployment;\n    abi: Readonly<Record<string, any>[]>;\n  };\n};\n\n/**\n * #### Summary\n * Zod Schema for {@link TContractMapWithAbi}\n */\n\nexport const contractMapWithAbiSchema: ZodType<TContractMapWithAbi> = z.record(\n  z.string({ description: 'contractName' }),\n  z.object({\n    config: z.record(\n      z.number({ description: 'chainId' }),\n      z.object({\n        address: z.string(),\n        chainId: z.number(),\n      })\n    ),\n    abi: z.array(z.any()),\n  })\n);\n\n/**\n * {chainId: {contract: address}}, contains an record of contracts\n * #### Summary\n * A type for external contracts\n * - it is a record of contract names and their deployed address\n * - this data type is used by {@link ContractsAppContext} to connect to external contracts\n *\n * @category Models\n */\nexport type TExternalContractsAddressMap = z.infer<typeof externalContractAddressMap>;\n\n/**\n * #### Summary\n * Zod Schema for {@link TExternalContractsAddressMap}\n */\nexport const externalContractAddressMap = z.record(\n  z\n    .union([z.string({ description: 'chainId' }), z.number({ description: 'chainId' })])\n    .transform((s) => parseInt(s.toString())),\n  z.record(z.string({ description: 'contractName' }), z.string({ description: 'address' }))\n);\n","import { QueryObserverOptions, QueryStatus } from 'react-query';\n\nimport { TEthersAdaptor } from './ethersAppContextTypes';\n\nimport { DeepPartial } from '~~/models/utilityTypes';\n\n/**\n * #### Summary\n * An constant for block number interval of 10 blocks\n */\nexport const const_blockNumberIntervalShort: DeepPartial<TUpdateOptions> = { blockNumberInterval: 10 };\n\n/**\n * #### Summary\n * An constant for block number interval of 50 blocks\n */\nexport const const_blockNumberIntervalMedium: DeepPartial<TUpdateOptions> = { blockNumberInterval: 50 };\n\n/**\n * #### Summary\n * An constant for block number interval of 250 blocks\n */\nexport const const_blockNumberIntervalLong: DeepPartial<TUpdateOptions> = { blockNumberInterval: 250 };\n\nexport type TQueryOptions<GResult> = Omit<\n  QueryObserverOptions<GResult, any>,\n  | 'refetchInterval'\n  | 'notifyOnChangeProps'\n  | 'notifyOnChangePropsExclusions'\n  | 'useErrorBoundary'\n  | 'refetchOnWindowFocus'\n  | 'refetchOnMount'\n  | 'refetchOnReconnect'\n> & {\n  refetchOnWindowFocus?: boolean | 'always';\n  refetchOnMount?: boolean | 'always';\n  refetchOnReconnect?: boolean | 'always';\n};\n\n/**\n * #### Summary\n * Options for hooks that describe the behviour of updates.\n * By default, depending on the hook, it will update every block.\n *\n * ##### ✏️ Notes\n * The following options are available:\n * - interval: interval in blocknumber to update in (default 1) see {@link TUpdateOptions.blockNumberInterval}\n * - polling: in ms, should be over 10000ms.  This is set by {@link TUpdateOptions.query.refetchInterval}\n */\nexport type TUpdateOptions<GResult = any> = {\n  /**\n   * The interval in blocknumber for the hook to update in (default 1)\n   */\n  blockNumberInterval: number | undefined;\n  refetchInterval?: number;\n  query?: TQueryOptions<GResult>;\n};\n\n/**\n * #### Summary\n * Ethers Provider options.  By default, the context provider is used by the hook.  If you want to use a different provider, you can:\n * - pass in an {@link TEthersAdaptor} to override the provider\n * - give the alternateContextKey for a secondary context provider.\n *\n * ##### ✏️ Notes\n * Adaptor\n * - To create a adaptor from a provider/signer see {@link useGetEthersAdaptorFromSignerOrProvider}\n * - You need to set adaptorEnabled to true\n *\n * Alternate Context Key\n * - For more info on alternateContextKey, see {@link TEthersAppContextProps} and [web3-react docs](https://github.com/NoahZinsmeister/web3-react/tree/v6/docs#createweb3reactroot).\n */\nexport type TOverride = {\n  /**\n   * An enable override adaptor (ethers provider) for this hook\n   */\n  adaptorEnabled: boolean;\n  /**\n   * The alternate adaptor to use.  See {@link TEthersAdaptor}\n   */\n  adaptor: TEthersAdaptor | undefined;\n\n  /**\n   * The alternate context key to use.  See {@link TEthersAppContextProps}\n   */\n  alternateContextKey?: string;\n};\n\n/**\n * An helper to create the default override settings for hooks\n * @returns {TOverride}\n */\nexport const defaultOverride = (): TOverride => {\n  return {\n    adaptorEnabled: false,\n    adaptor: undefined,\n    alternateContextKey: undefined,\n  };\n};\n\n/**\n * A helper to create default update options for hooks\n * @returns {TUpdateOptions}\n */\nexport const defaultUpdateOptions = <GResult = any>(): TUpdateOptions<GResult> => {\n  return {\n    blockNumberInterval: 1,\n    refetchInterval: undefined,\n    query: {\n      refetchOnWindowFocus: false,\n      refetchOnMount: true,\n      staleTime: 30000,\n    },\n  };\n};\n\n/**\n * #### Summary\n * This type describes the tuple that is returned by most hooks\n * 1. result: the result of the hook\n * 2. update: a callback will refresh the results of hook manually\n * 3. status: the status of the query.  From react-query: 'idle' | 'loading' | 'error' | 'success'. You can use this for UX purposes, see {@link QueryStatus}.\n */\nexport type THookResult<T> = [result: T, update: () => void, status: QueryStatus];\n","import { z, ZodType } from 'zod';\n\nexport type TForgeTransactionData = z.infer<typeof forgeTransactionDataSchema>;\nexport const forgeTransactionDataSchema = z.object({\n  type: z.string(),\n  from: z.string(),\n  gas: z.string(),\n  value: z.string(),\n  data: z.string(),\n  nonce: z.string(),\n  accessList: z.array(z.string()),\n});\n\nexport type TForgeTransaction = {\n  hash: string | null;\n  transactionType: 'CREATE' | Omit<string, 'CREATE'>;\n  contractName: string;\n  contractAddress: string;\n  function: string | null;\n  arguments: string | null;\n  transaction: TForgeTransactionData;\n};\n\nexport const forgeTransactionSchema: ZodType<TForgeTransaction> = z.object({\n  hash: z.string().nullable(),\n  transactionType: z.string(),\n  contractName: z.string(),\n  contractAddress: z.string(),\n  function: z.string().nullable(),\n  arguments: z.string().nullable(),\n  transaction: forgeTransactionDataSchema,\n});\n\nexport type TForgeBroadcastJson = {\n  transactions: TForgeTransaction[];\n};\n\nexport type TForgeDeploymentBroadcastCollection = {\n  [chainId: number]: TForgeBroadcastJson;\n};\n\nexport const forgeDeploymentBroadcastCollectionSchema: ZodType<TForgeDeploymentBroadcastCollection> = z.record(\n  z.union([z.number(), z.string()], { description: 'chainId' }).transform((t) => parseInt(t as string)),\n  z.object({\n    transactions: z.array(forgeTransactionSchema),\n  })\n);\n","import { z } from 'zod';\n\n/**\n * #### Summary\n * Describes the structure of hardhat_contracts.json\n * - {chainIds: { networkNames: {contracts} }}, contains an record of contracts\n * - Used by {@link useContractLoader}\n *\n * @category Models\n */\nexport type TDeployedHardhatContractsJson = z.infer<typeof deployedHardhatContractsJsonSchema>;\n\n/**\n * #### Summary\n * Zod Schema for {@link TBasicContractMap}\n */\nexport const deployedHardhatContractsJsonSchema = z.record(\n  z.union([z.string(), z.number()], { description: 'chainId' }).transform((s) => parseInt(s.toString())),\n  z\n    .object({\n      name: z.string({ description: 'contractName' }),\n      chainId: z.string({ description: 'chainId' }),\n      contracts: z.record(\n        z.string({ description: 'contractName' }),\n        z.object({\n          address: z.string(),\n          abi: z.array(z.any()).optional(),\n        })\n      ),\n    })\n    .array()\n);\n"]}