{"version":3,"sources":["../src/functions/asyncHelpers.ts","../src/functions/ethersHelpers.ts","../src/functions/hookHelpers.ts","../src/functions/keyHelpers.ts","../src/functions/parseProviderOrSigner.ts"],"names":["invariant","JsonRpcProvider","Provider","StaticJsonRpcProvider","Web3Provider","Signer"],"mappings":"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","sourcesContent":["/**\n * #### Summary\n * js .some function that can be used with async predicates\n *\n * @category Helpers\n *\n * @param arr\n * @param predicate\n * @returns\n */\nexport const asyncSome = async <T>(arr: Array<T>, predicate: (item: T) => Promise<boolean>): Promise<T | undefined> => {\n  for (const e of arr) {\n    if (await predicate(e)) return e;\n  }\n  return undefined;\n};\n\nexport const asyncForEach = async <T>(\n  array: Array<T>,\n  callback: (item: T, index: number) => Promise<void>\n): Promise<void> => {\n  for (let index = 0; index < array.length; index++) {\n    await callback(array[index], index);\n  }\n};\n","import {\n  Web3Provider,\n  StaticJsonRpcProvider,\n  JsonRpcProvider,\n  JsonRpcBatchProvider,\n  UrlJsonRpcProvider,\n  WebSocketProvider,\n} from '@ethersproject/providers';\nimport { Signer } from 'ethers';\n\nimport { providerKey } from '~~/functions';\nimport { TEthersProvider, IEthersContext, TEthersAdaptor } from '~~/models';\n\n/**\n * #### Summary\n * Is it a ethers compatable provider, used by {@link EthersModalConnector} and {@link useEthersProvider}\n *\n * @category Helpers\n *\n * @param providerBase\n * @returns\n */\nexport const isEthersProvider = (providerBase: unknown): boolean => {\n  if (providerBase == null) return false;\n  return (\n    providerBase instanceof Web3Provider ||\n    providerBase instanceof StaticJsonRpcProvider ||\n    providerBase instanceof JsonRpcProvider ||\n    providerBase instanceof UrlJsonRpcProvider ||\n    providerBase instanceof JsonRpcBatchProvider ||\n    providerBase instanceof WebSocketProvider\n  );\n};\n\nexport const signerHasNetwork = (signer: Signer | undefined): boolean => {\n  const provider = signer?.provider as TEthersProvider;\n  if (provider?.network?.chainId > 0 && signer?._isSigner) return true;\n\n  return false;\n};\n\nexport const asEthersAdaptor = (ethersContext: IEthersContext): Readonly<TEthersAdaptor> => {\n  return {\n    provider: ethersContext.provider,\n    signer: ethersContext.signer,\n    chainId: ethersContext.chainId,\n    account: ethersContext.account,\n  } as const;\n};\n\nexport const isValidEthersContext = (ethersContext: IEthersContext | undefined): boolean => {\n  if (\n    ethersContext != null &&\n    ethersContext.chainId != null &&\n    ethersContext.provider != null &&\n    ethersContext.signer != null &&\n    !!ethersContext.account\n  )\n    return true;\n  return false;\n};\n\nexport const isValidEthersAdaptor = (ethersAdaptor: TEthersAdaptor | undefined): boolean => {\n  if (ethersAdaptor != null && ethersAdaptor.chainId != null) {\n    if (ethersAdaptor.provider != null && ethersAdaptor.provider?.network?.chainId === ethersAdaptor.chainId) {\n      return true;\n    } else if (\n      ethersAdaptor.signer != null &&\n      !!ethersAdaptor.account &&\n      (ethersAdaptor?.signer?.provider as TEthersProvider)?.network?.chainId === ethersAdaptor.chainId\n    ) {\n      return true;\n    }\n  }\n\n  // console.log('isValidEthersAdaptorÏ€', false, ethersAdaptor);\n  return false;\n};\n\nexport const isAdaptorEqual = (adaptor1: TEthersAdaptor | undefined, adaptor2: TEthersAdaptor | undefined): boolean => {\n  if (isValidEthersAdaptor(adaptor1) && isValidEthersAdaptor(adaptor2)) {\n    return (\n      adaptor1?.chainId === adaptor2?.chainId &&\n      adaptor1?.account === adaptor2?.account &&\n      providerKey(adaptor1?.provider) === providerKey(adaptor2?.provider)\n    );\n  }\n  return false;\n};\n","import { merge } from 'merge-anything';\nimport { invariant } from 'ts-invariant';\n\nimport { asEthersAdaptor } from './ethersHelpers';\n\nimport {\n  TOverride,\n  IEthersContext,\n  TEthersAdaptor,\n  defaultOverride,\n  TUpdateOptions,\n  defaultUpdateOptions,\n  TQueryOptions,\n} from '~~/models';\nimport { DeepPartial } from '~~/models/utilityTypes';\n\nexport const ethersOverride = (context: IEthersContext, options: TOverride): Readonly<TEthersAdaptor> => {\n  // check if there is an override\n  if (options.adaptorEnabled) {\n    invariant(\n      options.alternateContextKey == null,\n      'You cannot use both contextOverride and contextKey at the same time'\n    );\n\n    return options.adaptor ?? {};\n  }\n\n  return asEthersAdaptor(context);\n};\n\n/**\n * #### Summary\n * Hook that will verify update options are valid\n *\n * @param update Options for updating to be verified\n */\nexport const checkUpdateOptions = (update: TUpdateOptions): void => {\n  // check if there is an override\n  if (update.refetchInterval) {\n    invariant(\n      update.refetchInterval >= 10000,\n      'Invalid refetchInterval (polling), must be at least 10000ms or undefined (disabled)'\n    );\n    invariant(\n      update.blockNumberInterval === undefined,\n      'You cannot use both refetchInterval (polling) and blockNumberInterval at the same time'\n    );\n  } else if (update.blockNumberInterval === undefined) {\n    invariant(update.blockNumberInterval, 'Invalid blockNumberInterval, it cannot be undefined unless polling is used');\n  } else {\n    invariant(update.blockNumberInterval > 0, 'Invalid blockNumberInterval, must be greater than 0');\n  }\n};\n\nexport const mergeDefaultOverride = (...overrides: DeepPartial<TOverride>[]): TOverride => {\n  const defaultOptions: TOverride = defaultOverride();\n\n  if (overrides?.length > 0) {\n    return merge(defaultOptions, ...overrides);\n  }\n\n  return defaultOptions;\n};\n\nexport const mergeDefaultUpdateOptions = <GResult = any>(\n  ...overrides: DeepPartial<TUpdateOptions<GResult>>[]\n): TUpdateOptions<GResult> => {\n  const mergedOverrides = merge({}, ...overrides) as TUpdateOptions<GResult>;\n  const defaultOptions: TUpdateOptions = defaultUpdateOptions();\n\n  if (overrides?.length > 0) {\n    // since check passed on overrides, if polling is enabled, then blockNumberInterval must have been disabled\n    if (mergedOverrides.refetchInterval) {\n      checkUpdateOptions(mergedOverrides);\n      defaultOptions.blockNumberInterval = undefined;\n    }\n    return merge(defaultOptions, mergedOverrides);\n  }\n\n  return defaultOptions;\n};\n\nexport const setContextOverride = (adaptor: TEthersAdaptor | undefined, enabled: boolean = true): TOverride => {\n  return mergeDefaultOverride({ adaptor, adaptorEnabled: enabled });\n};\n\nexport const processQueryOptions = <GResult>(\n  options: TUpdateOptions<GResult>\n): typeof options.query & { refetchInterval?: number } => {\n  checkUpdateOptions(options);\n\n  const queryOptions: TQueryOptions<GResult> & { refetchInterval?: number } = { ...options.query };\n  if (options.refetchInterval) {\n    queryOptions.enabled = true;\n    queryOptions.refetchInterval = options.refetchInterval;\n  }\n  return queryOptions;\n};\n","import { Provider } from '@ethersproject/providers';\nimport { BaseContract, Event, Signer } from 'ethers';\nimport { Result } from 'ethers/lib/utils';\nimport { QueryClient } from 'react-query';\nimport { invariant } from 'ts-invariant';\n\nimport { isValidEthersAdaptor } from '~~/functions';\nimport { TEthersAdaptor, TEthersProvider, TEthersProviderOrSigner, TypedEvent } from '~~/models';\n\nexport type TRequiredKeys = {\n  namespace: string;\n  key: string;\n};\n\nexport type TKeyTypes = {\n  provider?: string;\n  adaptor?: string;\n  contract?: string;\n  contractFunc?: string;\n};\n\n/**\n * Get a react-query query key fo ethers provider\n * @param providerOrSigner\n * @returns\n */\nexport const providerKey = (\n  providerOrSigner: TEthersProviderOrSigner | undefined\n): Record<'provider' | 'signer', string> => {\n  if (providerOrSigner == null) return { provider: 'undefined provider', signer: 'undefined signer' };\n\n  if (Provider.isProvider(providerOrSigner)) {\n    const provider = providerOrSigner as TEthersProvider;\n\n    return {\n      provider: `${provider?.network?.chainId}_${provider?.network?.name}_${provider?.connection.url.substring(0, 25)}`,\n      signer: 'isProvider',\n    };\n  } else {\n    const provider = (providerOrSigner as Signer).provider as TEthersProvider;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n    const signerStr: string = (providerOrSigner as any)?.address ?? '';\n    if (provider && provider?.network && Signer.isSigner(providerOrSigner)) {\n      return {\n        signer: `isSigner_${providerOrSigner._isSigner}_${signerStr}`,\n        provider: `${provider?.network?.chainId}_${provider?.network?.name}_${provider?.connection.url.substring(\n          0,\n          25\n        )}`,\n      };\n    }\n  }\n\n  return { provider: 'unknown provider', signer: 'unknown signer' };\n};\n\n/**\n * Get a react-query query key\n * @param adaptor\n * @returns\n */\nexport const adaptorKey = (adaptor: TEthersAdaptor | undefined): Partial<Record<'adaptor' | 'provider', string>> => {\n  if (adaptor == null && !isValidEthersAdaptor(adaptor)) return { adaptor: 'undefined adaptor' };\n\n  if (adaptor?.signer != null && adaptor.account != null && adaptor.provider != null) {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    return { adaptor: `${adaptor.chainId?.toString()}_${adaptor?.account}_${providerKey(adaptor?.provider ?? '')}` };\n  } else if (adaptor?.provider) {\n    return providerKey(adaptor?.provider);\n  }\n  return { adaptor: 'unknown adaptor' };\n};\n\n/**\n * Get a react-query query key\n * @param m\n * @returns\n */\nexport const eventKey = (m: Event | TypedEvent<Result>): string => {\n  return `${m.transactionHash}_${m.logIndex}`;\n};\n\n/**\n * Get a react-query query key\n * @param contract\n * @returns\n */\nexport const contractKey = (contract: BaseContract | undefined): Partial<Record<'contract' | 'provider', string>> => {\n  if (contract == null) return { contract: 'undefined contract' };\n\n  const address = contract.address;\n  const provider = providerKey(contract.provider as TEthersProvider | undefined);\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n  const signerStr: string = (contract.signer as any)?.address ?? '';\n  const fragments = contract.interface.fragments\n    .map((m) => m.name)\n    .reduce((oldValue, current) => {\n      let newValue = oldValue;\n      if (newValue == null) {\n        newValue = '';\n      }\n      newValue += `${current},`;\n      return newValue;\n    }, '');\n\n  return { contract: `${address}_${signerStr}_${fragments}`, ...provider };\n};\n\n/**\n * Get a react-query query key\n * @param contract\n * @param func\n * @returns\n */\nexport const contractFuncKey = (\n  contract: BaseContract | undefined,\n  func: ((...args: any[]) => Promise<any>) | undefined\n): Record<'contractFunc', string> => {\n  if (contract == null || func == null) return { contractFunc: 'undefined contract or contractFunc' };\n\n  let methodName: string | undefined = undefined;\n  Object.getOwnPropertyNames(contract).forEach((prop) => {\n    // @ts-expect-error\n    if (contract[prop] === func) {\n      methodName = prop;\n    }\n  });\n\n  if (methodName !== null) {\n    return { contractFunc: methodName ?? 'unknown contractFunc', ...contractKey(contract) };\n  }\n  return { contractFunc: 'unknown contractFunc', ...contractKey(contract) };\n};\n\nexport const invalidateCache = (\n  queryClient: QueryClient,\n  namespace: string,\n  otherKeys: TKeyTypes & { key?: string } = {},\n  variables: Record<string, any> = {}\n): void => {\n  void queryClient?.invalidateQueries?.([{ namespace, ...otherKeys }, variables]);\n};\n\nexport const logQueryCache = (\n  queryClient: QueryClient,\n  namespace: string,\n  otherKeys: TKeyTypes & { key?: string } = {},\n  variables: Record<string, any> = {}\n): void => {\n  invariant.log(queryClient.getQueriesData([{ namespace, ...otherKeys }, variables]));\n};\n","import { JsonRpcProvider, Provider, StaticJsonRpcProvider, Web3Provider } from '@ethersproject/providers';\nimport { ethers, Signer } from 'ethers';\nimport { invariant } from 'ts-invariant';\n\nimport { isValidEthersAdaptor } from '~~/functions';\nimport { TEthersProviderOrSigner, TEthersProvider } from '~~/models';\nimport { TEthersAdaptor } from '~~/models/ethersAppContextTypes';\n\nexport const isProvider = (providerOrSigner: TEthersProviderOrSigner | undefined): boolean => {\n  const casted = providerOrSigner as TEthersProvider;\n\n  if (\n    providerOrSigner instanceof JsonRpcProvider ||\n    providerOrSigner instanceof Web3Provider ||\n    providerOrSigner instanceof StaticJsonRpcProvider\n  ) {\n    return true;\n  } else if (Provider.isProvider(providerOrSigner)) {\n    return true;\n  } else if (\n    casted?._isProvider &&\n    casted?.getNetwork != null &&\n    typeof casted?.getNetwork == 'function' &&\n    casted.listAccounts != null &&\n    typeof casted.listAccounts == 'function'\n  ) {\n    // fallback check incase of inter library calls and differences in deps.\n    return true;\n  }\n  return false;\n};\n\nconst isSigner = (providerOrSigner: TEthersProviderOrSigner | undefined): boolean => {\n  const casted = providerOrSigner as Signer;\n\n  if (providerOrSigner instanceof ethers.Signer) {\n    return true;\n  } else if (Signer.isSigner(providerOrSigner)) {\n    return true;\n  } else if (\n    casted?._isSigner &&\n    typeof casted?.provider != null &&\n    casted?.signMessage != null &&\n    typeof casted?.signMessage == 'function'\n  ) {\n    // fallback check incase of inter library calls and differences in deps.\n    return true;\n  }\n  return false;\n};\n\n/**\n * #### Summary\n * Parse {@link TEthersProviderOrSigner} to {@link TEthersUser}\n * Get the TEthersUser from a provider or signer\n *\n * @category Helpers\n *\n * @param providerOrSigner TEthersProviderOrSigner\n * @returns TProviderAndSigner\n */\nexport const parseProviderOrSigner = async (\n  providerOrSigner: TEthersProviderOrSigner | undefined\n): Promise<Readonly<TEthersAdaptor> | undefined> => {\n  let signer: Signer | undefined;\n  let provider: ethers.providers.Provider | undefined;\n  let providerNetwork: ethers.providers.Network | undefined;\n  let account: string | undefined;\n\n  try {\n    if (isProvider(providerOrSigner)) {\n      const casted = providerOrSigner as TEthersProvider;\n      provider = casted;\n      providerNetwork = await casted.getNetwork();\n      const accounts = await casted.listAccounts();\n      if (accounts && accounts.length > 0) {\n        signer = casted.getSigner();\n      }\n    }\n\n    if (!signer && isSigner(providerOrSigner)) {\n      const casted = providerOrSigner as Signer;\n      signer = casted;\n      provider = casted.provider;\n      providerNetwork = casted.provider && (await casted.provider.getNetwork());\n    }\n\n    if (signer) {\n      account = await signer?.getAddress();\n    }\n\n    const result: TEthersAdaptor = {\n      signer,\n      provider: provider as TEthersProvider,\n      chainId: providerNetwork?.chainId,\n      account,\n    } as const;\n\n    if (isValidEthersAdaptor(result)) return result;\n  } catch (error) {\n    invariant.warn('parseProviderOrSigner error:', error, providerOrSigner);\n  }\n\n  return undefined;\n};\n"]}