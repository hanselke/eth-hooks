{"version":3,"sources":["../src/hooks/dapps/useDexEthPrice.ts","../src/hooks/dapps/useDexTokenList.ts","../src/hooks/dapps/useResolveEnsName.ts","../src/hooks/dapps/useResolveEnsAddress.ts"],"names":["keys","useQuery","queryKey","tokenListUri","chainId","address","constants","ensName"],"mappings":";;;;;;;;;;;;;;;AAAA,SAAS,OAAO,MAAM,SAAS,aAAa;AAC5C,SAAS,gBAAgB;AASzB,IAAM,WAA0B,EAAE,WAAW,aAAa,QAAQ,KAAK,iBAAiB;AAgBjF,IAAM,iBAAiB,CAC5B,iBACA,mBACA,UAA0B,0BAA0B,MAC5B;AACxB,QAAM,OAAO,CAAC,EAAE,GAAG,UAAU,GAAG,YAAY,eAAe,EAAE,GAAG,EAAE,cAAc,uDAAmB,MAAM,CAAC;AAG1G,QAAM,EAAE,MAAM,SAAS,OAAO,IAAI;AAAA,IAChC;AAAA,IACA,OAAOA,UAAgC;AACrC,YAAM,EAAE,aAAa,IAAIA,MAAK,SAAS;AACvC,UAAI,cAAc;AAChB,eAAO;AAAA,MACT,WAAW,iBAAiB;AAC1B,cAAM,UAAU,MAAM,gBAAgB,WAAW;AAEjD,cAAM,MAAM,IAAI,MAAM,UAAU,QAAQ,UAAU,GAAG,8CAA8C,EAAE;AACrG,cAAM,OAAO,MAAM,QAAQ,cAAc,KAAK,KAAK,IAAI,UAAU,eAAe;AAChF,cAAM,QAAQ,IAAI,MAAM,CAAC,IAAI,GAAG,KAAK,IAAI,QAAQ;AACjD,cAAM,QAAQ,WAAW,MAAM,SAAS,cAAc,CAAC,CAAC;AACxD,eAAO;AAAA,MACT;AAAA,IACF;AAAA,IACA;AAAA,MACE,GAAG,oBAAkC,OAAO;AAAA,IAC9C;AAAA,EACF;AAEA,QAAM,cAAc,sBAAsB;AAC1C,mBAAiB,SAAS,aAAa,OAAO;AAE9C,SAAO,CAAC,QAAQ,GAAG,SAAS,MAAM;AACpC;;;AC1DA,OAAO,aAAa;AACpB,SAAS,YAAAC,iBAAgB;AAQzB,IAAMC,YAA0B,EAAE,WAAW,aAAa,QAAQ,KAAK,kBAAkB;AAelF,IAAM,kBAAkB,CAC7B,eAAuB,mDACvB,SACA,UAA0B,0BAA0B,MACvB;AAC7B,QAAM,OAAO,CAAC,EAAE,GAAGA,UAAS,GAAG,EAAE,cAAc,QAAQ,CAAC;AACxD,QAAM,EAAE,MAAM,SAAS,OAAO,IAAID;AAAA,IAChC;AAAA,IACA,OAAOD,UAA+B;AACpC,YAAM,EAAE,cAAAG,eAAc,SAAAC,SAAQ,IAAIJ,MAAK,SAAS;AAChD,UAAI,YAAyB,CAAC;AAC9B,YAAM,WAAW,MAAM,MAAMG,aAAY;AACzC,YAAM,YAAwB,MAAM,SAAS,KAAK;AAClD,UAAI,aAAa,MAAM;AACrB,YAAIC,UAAS;AACX,sBAAY,UAAU,OAAO,OAAO,CAAC,MAAiB;AACpD,mBAAO,EAAE,YAAYA;AAAA,UACvB,CAAC;AAAA,QACH,OAAO;AACL,sBAAY,UAAU;AAAA,QACxB;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,MACE,GAAG,oBAAiC,OAAO;AAAA,MAC3C,aAAa,CAAC,WAAW,cAAc,QAAQ,WAAW,SAAS;AAAA,IACrE;AAAA,EACF;AAEA,QAAM,cAAc,sBAAsB;AAC1C,mBAAiB,SAAS,aAAa,OAAO;AAE9C,SAAO,CAAC,QAAQ,CAAC,GAAG,SAAS,MAAM;AACrC;;;AC3DA,SAAS,OAAO,iBAAiB;AACjC,SAAS,YAAAH,iBAAgB;AAKzB,IAAMC,YAA0B,EAAE,WAAW,aAAa,QAAQ,KAAK,oBAAoB;AAS3F,IAAM,gBAAgB,OAAO,UAA2B,YAAqC;AAC3F,MAAI,MAAM,UAAU,OAAO,GAAG;AAC5B,QAAI;AAGF,YAAM,eAAe,MAAM,SAAS,cAAc,OAAO;AACzD,YAAM,kBAAkB,MAAM,SAAS,YAAY,gBAAgB,UAAU,WAAW;AACxF,UAAI,WAAW,MAAM,WAAW,OAAO,MAAM,MAAM,WAAW,mBAAmB,EAAE,GAAG;AACpF,eAAO,gBAAgB;AAAA,MACzB,OAAO;AACL,eAAO,MAAM,WAAW,OAAO;AAAA,MACjC;AAAA,IACF,SAAS,GAAP;AACA,aAAO,MAAM,WAAW,OAAO;AAAA,IACjC;AAAA,EACF;AACA,SAAO;AACT;AAYO,IAAM,oBAAoB,CAC/B,iBACA,YACoC;AACpC,QAAM,OAAO,CAAC,EAAE,GAAGA,WAAU,GAAG,YAAY,eAAe,EAAE,GAAG,EAAE,QAAQ,CAAC;AAC3E,QAAM,EAAE,MAAM,SAAS,OAAO,IAAID,UAAS,MAAM,OAAOD,UAAsC;AAC5F,UAAM,EAAE,SAAAK,SAAQ,IAAIL,MAAK,SAAS;AAElC,UAAM,aAAqB,OAAO,aAAa,QAAQ,uBAAuBK,QAAO;AACrF,UAAM,QAAQ,KAAK,MAAM,cAAc,IAAI;AAC3C,QAAI,UAAS,+BAAO,UAAQ,+BAAO,aAAY,KAAK,IAAI,KAAK,QAAO,+BAAO,UAAS,UAAU;AAC5F,aAAO,+BAAO;AAAA,IAChB,WAAW,iBAAiB;AAC1B,YAAM,UAAU,MAAM,cAAc,iBAAiBA,QAAO;AAC5D,UAAI,SAAS;AACX,YAAI;AACF,iBAAO,aAAa;AAAA,YAClB,cAAcA;AAAA,YACd,KAAK,UAAU;AAAA,cACb,WAAW,KAAK,IAAI,IAAI;AAAA,cACxB,MAAM;AAAA,YACR,CAAC;AAAA,UACH;AAAA,QACF,QAAE;AAAA,QAEF;AACA,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF,CAAC;AAED,SAAO,CAAC,MAAM,SAAS,MAAM;AAC/B;;;AC5EA,SAAS,aAAAC,kBAAiB;AAC1B,SAAS,YAAAL,iBAAgB;AAKzB,IAAMC,YAA0B,EAAE,WAAW,aAAa,QAAQ,KAAK,uBAAuB;AAYvF,IAAM,uBAAuB,CAClC,iBACA,YACoC;AACpC,QAAM,OAAO,CAAC,EAAE,GAAGA,WAAU,GAAG,YAAY,eAAe,EAAE,GAAG,EAAE,QAAQ,CAAC;AAC3E,QAAM,EAAE,MAAM,SAAS,OAAO,IAAID,UAAS,MAAM,OAAOD,UAAsC;AAC5F,UAAM,EAAE,SAAAO,SAAQ,IAAIP,MAAK,SAAS;AAClC,QAAI,mBAAmBO,UAAS;AAC9B,YAAM,WAAW,MAAM,gBAAgB,YAAYA,QAAO;AAC1D,aAAO,YAAYD,WAAU;AAAA,IAC/B;AACA,WAAOA,WAAU;AAAA,EACnB,CAAC;AAED,SAAO,CAAC,MAAM,SAAS,MAAM;AAC/B","sourcesContent":["import { Token, WETH, Fetcher, Route } from '@uniswap/sdk';\nimport { useQuery } from 'react-query';\n\nimport { useBlockNumberContext } from '~~/context';\nimport { mergeDefaultUpdateOptions, processQueryOptions, providerKey, TRequiredKeys } from '~~/functions';\nimport { useEthersUpdater } from '~~/hooks/useEthersUpdater';\nimport { THookResult, TNetworkInfo, TUpdateOptions } from '~~/models';\nimport { keyNamespace } from '~~/models/constants';\nimport { TEthersProvider } from '~~/models/providerTypes';\n\nconst queryKey: TRequiredKeys = { namespace: keyNamespace.signer, key: 'useDexEthPrice' } as const;\n\n/**\n * #### Summary\n * Get the Exchange price of ETH/USD (extrapolated from WETH/DAI) from uniswap\n *\n * ##### ✏️ Notes\n * - uses useOnRepetition, does not use context\n *\n * @category Hooks\n *\n * @param mainnetProvider\n * @param targetNetworkInfo\n * @param pollTime if >0 use polling, else use instead of onBlock event\n * @returns price in USD\n */\nexport const useDexEthPrice = (\n  mainnetProvider: TEthersProvider | undefined,\n  targetNetworkInfo?: TNetworkInfo,\n  options: TUpdateOptions = mergeDefaultUpdateOptions()\n): THookResult<number> => {\n  const keys = [{ ...queryKey, ...providerKey(mainnetProvider) }, { networkPrice: targetNetworkInfo?.price }] as const;\n  type TAsyncResult = number | undefined;\n\n  const { data, refetch, status } = useQuery(\n    keys,\n    async (keys): Promise<TAsyncResult> => {\n      const { networkPrice } = keys.queryKey[1];\n      if (networkPrice) {\n        return networkPrice;\n      } else if (mainnetProvider) {\n        const network = await mainnetProvider.getNetwork();\n\n        const DAI = new Token(network ? network.chainId : 1, '0x6B175474E89094C44Da98b954EedeAC495271d0F', 18);\n        const pair = await Fetcher.fetchPairData(DAI, WETH[DAI.chainId], mainnetProvider);\n        const route = new Route([pair], WETH[DAI.chainId]);\n        const price = parseFloat(route.midPrice.toSignificant(6));\n        return price;\n      }\n    },\n    {\n      ...processQueryOptions<TAsyncResult>(options),\n    }\n  );\n\n  const blockNumber = useBlockNumberContext();\n  useEthersUpdater(refetch, blockNumber, options);\n\n  return [data ?? 0, refetch, status];\n};\n","import { TokenInfo, TokenList } from '@uniswap/token-lists';\nimport isEqual from 'lodash.isequal';\nimport { useQuery } from 'react-query';\n\nimport { useBlockNumberContext } from '~~/context';\nimport { mergeDefaultUpdateOptions, processQueryOptions, TRequiredKeys } from '~~/functions';\nimport { useEthersUpdater } from '~~/hooks/useEthersUpdater';\nimport { THookResult, TUpdateOptions } from '~~/models';\nimport { keyNamespace } from '~~/models/constants';\n\nconst queryKey: TRequiredKeys = { namespace: keyNamespace.signer, key: 'useDexTokenList' } as const;\n\n/**\n * #### Summary\n * Gets a tokenlist from uniswap ipfs tokenlist\n *\n * ##### ✏️ Notes\n * - you can also point it to another URI\n *\n * @category Hooks\n *\n * @param tokenListUri\n * @param chainId optional, you can filter by a particular chainId\n * @returns (TokenInfo[]) from '@uniswap/token-lists'\n */\nexport const useDexTokenList = (\n  tokenListUri: string = 'https://gateway.ipfs.io/ipns/tokens.uniswap.org',\n  chainId?: number,\n  options: TUpdateOptions = mergeDefaultUpdateOptions()\n): THookResult<TokenInfo[]> => {\n  const keys = [{ ...queryKey }, { tokenListUri, chainId }] as const;\n  const { data, refetch, status } = useQuery(\n    keys,\n    async (keys): Promise<TokenInfo[]> => {\n      const { tokenListUri, chainId } = keys.queryKey[1];\n      let tokenInfo: TokenInfo[] = [];\n      const response = await fetch(tokenListUri);\n      const tokenList: TokenList = (await response.json()) as TokenList;\n      if (tokenList != null) {\n        if (chainId) {\n          tokenInfo = tokenList.tokens.filter((t: TokenInfo) => {\n            return t.chainId === chainId;\n          });\n        } else {\n          tokenInfo = tokenList.tokens;\n        }\n      }\n      return tokenInfo;\n    },\n    {\n      ...processQueryOptions<TokenInfo[]>(options),\n      isDataEqual: (oldResult, newResult) => isEqual(oldResult, newResult),\n    }\n  );\n\n  const blockNumber = useBlockNumberContext();\n  useEthersUpdater(refetch, blockNumber, options);\n\n  return [data ?? [], refetch, status];\n};\n","import { utils, constants } from 'ethers';\nimport { useQuery } from 'react-query';\n\nimport { providerKey, TRequiredKeys } from '~~/functions';\nimport { keyNamespace, TEthersProvider, THookResult } from '~~/models';\n\nconst queryKey: TRequiredKeys = { namespace: keyNamespace.signer, key: 'useResolveEnsName' } as const;\n\n/**\n * @internal\n *\n * @param provider\n * @param address\n * @returns\n */\nconst lookupAddress = async (provider: TEthersProvider, address: string): Promise<string> => {\n  if (utils.isAddress(address)) {\n    try {\n      // Accuracy of reverse resolution is not enforced.\n      // We then manually ensure that the reported ens name resolves to address\n      const reportedName = await provider.lookupAddress(address);\n      const resolvedAddress = await provider.resolveName(reportedName ?? constants.AddressZero);\n      if (address && utils.getAddress(address) === utils.getAddress(resolvedAddress ?? '')) {\n        return reportedName ?? '';\n      } else {\n        return utils.getAddress(address);\n      }\n    } catch (e) {\n      return utils.getAddress(address);\n    }\n  }\n  return '';\n};\n\n/**\n * #### Summary\n * Gets ENS name for given address\n *\n * @category Hooks\n *\n * @param mainnetProvider mainnet provider\n * @param address\n * @returns\n */\nexport const useResolveEnsName = (\n  mainnetProvider: TEthersProvider | undefined,\n  address: string\n): THookResult<string | undefined> => {\n  const keys = [{ ...queryKey, ...providerKey(mainnetProvider) }, { address }] as const;\n  const { data, refetch, status } = useQuery(keys, async (keys): Promise<string | undefined> => {\n    const { address } = keys.queryKey[1];\n\n    const storedData: string = window.localStorage.getItem('ethhooks_ensCache_' + address) as string;\n    const cache = JSON.parse(storedData ?? '{}') as Record<string, any>;\n    if (cache && cache?.name && cache?.timestamp > Date.now() && typeof cache?.name === 'string') {\n      return cache?.name;\n    } else if (mainnetProvider) {\n      const ensName = await lookupAddress(mainnetProvider, address);\n      if (ensName) {\n        try {\n          window.localStorage.setItem(\n            'ensCache_' + address,\n            JSON.stringify({\n              timestamp: Date.now() + 360000,\n              name: ensName,\n            })\n          );\n        } catch {\n          /* do nothing */\n        }\n        return ensName;\n      }\n    }\n  });\n\n  return [data, refetch, status];\n};\n","import { constants } from 'ethers';\nimport { useQuery } from 'react-query';\n\nimport { providerKey, TRequiredKeys } from '~~/functions';\nimport { keyNamespace, TEthersProvider, THookResult } from '~~/models';\n\nconst queryKey: TRequiredKeys = { namespace: keyNamespace.signer, key: 'useResolveEnsAddress' } as const;\n\n/**\n * #### Summary\n * Gets the address from an ENS name\n *\n * @category Hooks\n *\n * @param mainnetProvider mainnet provider\n * @param ensName\n * @returns\n */\nexport const useResolveEnsAddress = (\n  mainnetProvider: TEthersProvider | undefined,\n  ensName: string | undefined\n): THookResult<string | undefined> => {\n  const keys = [{ ...queryKey, ...providerKey(mainnetProvider) }, { ensName }] as const;\n  const { data, refetch, status } = useQuery(keys, async (keys): Promise<string | undefined> => {\n    const { ensName } = keys.queryKey[1];\n    if (mainnetProvider && ensName) {\n      const resolved = await mainnetProvider.resolveName(ensName);\n      return resolved ?? constants.AddressZero;\n    }\n    return constants.AddressZero;\n  });\n\n  return [data, refetch, status];\n};\n"]}