import { PluginSmartEqRules, SmartEqRule } from '../plugins/types';
import { NonEmptyOnly } from '../types';
declare type ErrorReasons = 'value mismatch' | 'prototype mismatch' | 'object possibly infinite';
export declare type SmartEqResult = {
    result: 'success';
} | {
    result: 'error';
    reason: ErrorReasons;
};
export declare function buildSmartEqResult(success: boolean, reason?: ErrorReasons): SmartEqResult;
export declare const smartEqRules: SmartEqRule<unknown, unknown>[];
export declare function loadSmartEqRules(rules: PluginSmartEqRules<never>): void;
export declare function clearSmartEqRules(): void;
export interface SmartEqRules {
}
export declare namespace SmartEqRules {
    type Expected<TEqRule> = TEqRule extends SmartEqRule<any, infer TExpected> ? TExpected : never;
}
export declare type ExpectedEqual<TActual> = TActual | SmartEqRules.Expected<Extract<SmartEqRules[keyof SmartEqRules], SmartEqRule<TActual, never>>> | NonEmptyOnly<TActual extends object ? {
    [K in keyof TActual]: ExpectedEqual<TActual[K]>;
} : never>;
export {};
