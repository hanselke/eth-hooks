"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatArrayEntries = void 0;
const formatUnknown_1 = require("./formatUnknown");
const getOptionsWith_1 = require("./getOptionsWith");
function formatArrayEntries(value, sibling, options, valueStack, siblingStack) {
    var _a;
    const entries = [];
    const passedOptions = (0, getOptionsWith_1.getOptionsWith)(options, {
        requireStrictEquality: false,
        maxLineLength: options.maxLineLength - 10,
    });
    let empty = 0;
    for (let i = 0; i < value.length; i++) {
        if (!value.hasOwnProperty(i.toString())) {
            empty++;
        }
        else {
            if (empty !== 0) {
                entries.push(formatEmpty(empty));
                empty = 0;
            }
            const nestedOptions = (0, getOptionsWith_1.getOptionsWith)(passedOptions, {
                skipMatcherReplacement: passedOptions.skipMatcherReplacement ||
                    (!!sibling && !Object.prototype.hasOwnProperty.call(sibling, i.toString())),
            });
            const valueFormat = (0, formatUnknown_1.formatUnknown)(value[i], (_a = sibling) === null || _a === void 0 ? void 0 : _a[i], nestedOptions, valueStack, siblingStack);
            for (const line of valueFormat) {
                line[0] += 1;
            }
            entries.push(...valueFormat);
        }
    }
    if (empty !== 0) {
        entries.push(formatEmpty(empty));
    }
    return entries;
}
exports.formatArrayEntries = formatArrayEntries;
function formatEmpty(empty) {
    if (empty === 1) {
        return [1, '<empty>'];
    }
    else {
        return [1, `<${empty} empty items>`];
    }
}
