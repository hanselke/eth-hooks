"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatUnknown = void 0;
const isEqual_1 = require("../isEqual");
const matchers_1 = require("../matchers");
const formatArrayEntries_1 = require("./formatArrayEntries");
const formatMapEntries_1 = require("./formatMapEntries");
const formatNumber_1 = require("./formatNumber");
const formatObjectEntries_1 = require("./formatObjectEntries");
const formatSetEntries_1 = require("./formatSetEntries");
const formatString_1 = require("./formatString");
const formatSymbol_1 = require("./formatSymbol");
const getComparedTypeName_1 = require("./getComparedTypeName");
const getRepresentation_1 = require("./getRepresentation");
const toLine_1 = require("./toLine");
function formatUnknown(value, sibling, options, valueStack, siblingStack) {
    const type = (0, isEqual_1.getCanonicalType)(value);
    switch (type) {
        case 'null':
        case 'undefined':
        case 'boolean':
            return (0, toLine_1.toLine)(`${value}`);
        case 'string':
            return (0, toLine_1.toLine)((0, formatString_1.formatString)(value, options));
        case 'bigint':
            return (0, toLine_1.toLine)(`${value}n`);
        case 'number':
            return (0, formatNumber_1.formatNumber)(value, sibling, options);
        case 'symbol':
            return (0, formatSymbol_1.formatSymbol)(value, sibling);
    }
    if (value instanceof matchers_1.Matcher) {
        if (!options.skipMatcherReplacement && value.check(sibling)) {
            return formatUnknown(sibling, null, options, siblingStack, []);
        }
        else {
            let line = `Matcher ${value.toString()}`;
            if (options.inline && line.length > options.maxLineLength) {
                line = 'Matcher';
            }
            return (0, toLine_1.toLine)(line);
        }
    }
    const selfIndex = valueStack.indexOf(value);
    if (selfIndex !== -1) {
        const dots = '.'.repeat(valueStack.length - selfIndex);
        return (0, toLine_1.toLine)(`<Circular ${dots}>`);
    }
    const items = [];
    const { typeName, isDifferentPrototype, isSameTypeName } = (0, getComparedTypeName_1.getComparedTypeName)(value, sibling, type, options.ignorePrototypes);
    if (typeName) {
        items.push(typeName);
    }
    if (isDifferentPrototype) {
        items.push('(different prototype)');
    }
    if (options.requireStrictEquality ||
        type === 'Promise' ||
        type === 'WeakMap' ||
        type === 'WeakSet' ||
        type === 'Function') {
        if (value !== sibling && isSameTypeName && !isDifferentPrototype) {
            items.push('(different)');
        }
    }
    if (type === 'Promise' || type === 'WeakMap' || type === 'WeakSet') {
        return (0, toLine_1.toLine)(items.join(' '));
    }
    if (type === 'Error' && options.inline && options.maxLineLength !== Infinity) {
        return (0, toLine_1.toLine)(`${typeName}(${(0, formatString_1.formatString)(value.message, options)})`);
    }
    const representation = (0, getRepresentation_1.getRepresentation)(value, type, options);
    if (representation) {
        items.push(representation);
    }
    const entries = [];
    valueStack.push(value);
    siblingStack.push(sibling);
    if (type === 'Array') {
        entries.push(...(0, formatArrayEntries_1.formatArrayEntries)(value, sibling, options, valueStack, siblingStack));
    }
    else if (type === 'Set') {
        entries.push(...(0, formatSetEntries_1.formatSetEntries)(value, sibling, options, valueStack, siblingStack));
    }
    else if (type === 'Map') {
        entries.push(...(0, formatMapEntries_1.formatMapEntries)(value, sibling, options, valueStack, siblingStack));
    }
    entries.push(...(0, formatObjectEntries_1.formatObjectEntries)(value, sibling, options, valueStack, siblingStack));
    valueStack.pop();
    siblingStack.pop();
    const skipObjectIfEmpty = type === 'Date' ||
        type === 'Function' ||
        type === 'RegExp' ||
        type === 'String' ||
        type === 'Number' ||
        type === 'Boolean';
    if (entries.length === 0) {
        if (!skipObjectIfEmpty) {
            items.push(type === 'Array' ? '[]' : '{}');
        }
        return (0, toLine_1.toLine)(items.join(' '));
    }
    if (skipObjectIfEmpty) {
        items.push('&');
    }
    items.push(type === 'Array' ? '[' : '{');
    const beginning = items.join(' ');
    if (options.inline) {
        let jointEntries = entries.map((x) => x[1]).join(', ');
        if (jointEntries.length > options.maxLineLength) {
            jointEntries = entries.length === 1 ? '1 entry' : `${entries.length} entries`;
        }
        if (type === 'Array') {
            return (0, toLine_1.toLine)(`${beginning}${jointEntries}]`);
        }
        else {
            return (0, toLine_1.toLine)(`${beginning} ${jointEntries} }`);
        }
    }
    else {
        entries.unshift([0, beginning]);
        entries.push([0, type === 'Array' ? ']' : '}']);
        return entries;
    }
}
exports.formatUnknown = formatUnknown;
