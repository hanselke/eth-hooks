"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerWithMatcher = void 0;
const format_1 = require("../format");
const ArrayWith_1 = require("./ArrayWith");
const Base_1 = require("./Base");
class ContainerWithMatcher extends Base_1.Matcher {
    constructor(expectedItems) {
        super();
        this.expectedItems = expectedItems;
    }
    check(actualItems) {
        if (!isIterableAndNotString(actualItems)) {
            return false;
        }
        const items = Array.from(actualItems);
        return (0, ArrayWith_1.contains)(this.expectedItems, items);
    }
    toString() {
        return `[ContainerWith: ${(0, format_1.formatCompact)(this.expectedItems)}]`;
    }
    // TODO: for now this has to be typed as any. Otherwise types won't match ie.
    // toEqual([1], ContainerWithMatcher.make(...))
    // [1] has to have exactly the same type as return of this function
    // if we type it as T[] it's fine but then it won't work with iterators
    // if we type is as IterableIterator<T> then it is not assignable to T[] anymore :/
    // this is a problem for all polymorphic matchers
    static make(...items) {
        return new ContainerWithMatcher(items);
    }
}
exports.ContainerWithMatcher = ContainerWithMatcher;
function isIterableAndNotString(value) {
    return Symbol.iterator in Object(value) && typeof value !== 'string';
}
