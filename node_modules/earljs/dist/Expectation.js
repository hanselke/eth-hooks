"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getControl = exports.loadValidators = exports.__ExpectationImplementation = void 0;
const Control_1 = require("./Control");
const Anything_1 = require("./matchers/Anything");
const Error_1 = require("./matchers/Error");
const booleans_1 = require("./validators/booleans");
const dataStructures_1 = require("./validators/dataStructures");
const mocks_1 = require("./validators/mocks");
const numbers_1 = require("./validators/numbers");
const optionals_1 = require("./validators/optionals");
const toMatchSnapshot_1 = require("./validators/snapshots/toMatchSnapshot");
const toBeA_1 = require("./validators/toBeA");
const toBeRejected_1 = require("./validators/toBeRejected");
const toEqual_1 = require("./validators/toEqual");
const toLooseEqual_1 = require("./validators/toLooseEqual");
const toReferentiallyEqual_1 = require("./validators/toReferentiallyEqual");
const toThrow_1 = require("./validators/toThrow");
/**
 * @internal
 */
class __ExpectationImplementation {
    constructor(actual, isNegated = false, options = {}) {
        this.actual = actual;
        this.isNegated = isNegated;
        this.options = options;
        for (const [name, validator] of Object.entries(dynamicValidators)) {
            ;
            this[name] = validator;
        }
    }
    static make(actual, isNegated = false, options = {}) {
        const instance = new __ExpectationImplementation(actual, isNegated, options);
        return instance;
    }
    // modifiers
    get not() {
        if (this.isNegated) {
            throw new Error('Tried negating an already negated expectation');
        }
        return new __ExpectationImplementation(this.actual, true, this.options);
    }
    toEqual(value) {
        (0, toEqual_1.toEqual)(this.getControl(), value);
    }
    toLooseEqual(value) {
        (0, toLooseEqual_1.toLooseEqual)(this.getControl(), value);
    }
    toReferentiallyEqual(value) {
        (0, toReferentiallyEqual_1.toReferentiallyEqual)(this.getControl(), value);
    }
    toThrow(classOrMessage, message) {
        if (arguments.length === 0) {
            (0, toThrow_1.toThrow)(this.getControl(), Anything_1.AnythingMatcher.make());
        }
        else {
            (0, toThrow_1.toThrow)(this.getControl(), Error_1.ErrorMatcher.make(classOrMessage, message));
        }
    }
    toBeRejected(classOrMessage, message) {
        if (arguments.length === 0) {
            return (0, toBeRejected_1.toBeRejected)(this.getControl(), Anything_1.AnythingMatcher.make());
        }
        else {
            return (0, toBeRejected_1.toBeRejected)(this.getControl(), Error_1.ErrorMatcher.make(classOrMessage, message));
        }
    }
    toBeA(clazz) {
        return (0, toBeA_1.toBeA)(this.getControl(), clazz);
    }
    toBeAContainerWith(...expectedItems) {
        return (0, dataStructures_1.toBeAContainerWith)(this.getControl(), expectedItems);
    }
    toBeAnArrayOfLength(length) {
        return (0, dataStructures_1.toBeAnArrayOfLength)(this.getControl(), length);
    }
    toBeAnArrayWith(...expectedItems) {
        return (0, dataStructures_1.toBeAnArrayWith)(this.getControl(), expectedItems);
    }
    toBeAnObjectWith(subset) {
        return (0, dataStructures_1.toBeAnObjectWith)(this.getControl(), subset);
    }
    toBeGreaterThan(target) {
        return (0, numbers_1.toBeGreaterThan)(this.getControl(), target);
    }
    toBeGreaterThanOrEqualTo(target) {
        return (0, numbers_1.toBeGreaterThanOrEqualTo)(this.getControl(), target);
    }
    toBeLessThan(target) {
        return (0, numbers_1.toBeLessThan)(this.getControl(), target);
    }
    toBeLessThanOrEqualTo(target) {
        return (0, numbers_1.toBeLessThanOrEqualTo)(this.getControl(), target);
    }
    toBeTruthy() {
        return (0, booleans_1.toBeTruthy)(this.getControl());
    }
    toBeFalsy() {
        return (0, booleans_1.toBeFalsy)(this.getControl());
    }
    toBeDefined() {
        return (0, optionals_1.toBeDefined)(this.getControl());
    }
    toBeNullish() {
        return (0, optionals_1.toBeNullish)(this.getControl());
    }
    toBeExhausted() {
        return (0, mocks_1.toBeExhausted)(this.getControl());
    }
    toHaveBeenCalledWith(args) {
        return (0, mocks_1.toHaveBeenCalledWith)(this.getControl(), args);
    }
    toHaveBeenCalledExactlyWith(args) {
        return (0, mocks_1.toHaveBeenCalledExactlyWith)(this.getControl(), args);
    }
    toMatchSnapshot() {
        (0, toMatchSnapshot_1.toMatchSnapshot)(this.getControl());
    }
    // utilities
    getControl() {
        return new Control_1.Control(this.actual, this.isNegated, this.options.extraMessage);
    }
}
exports.__ExpectationImplementation = __ExpectationImplementation;
const dynamicValidators = {};
function loadValidators(validators) {
    for (const [name, validator] of Object.entries(validators)) {
        dynamicValidators[name] = validator;
    }
}
exports.loadValidators = loadValidators;
function getControl(expectation) {
    return expectation['getControl']();
}
exports.getControl = getControl;
