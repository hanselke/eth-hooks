import { Control } from './Control';
import { ExpectedEqual } from './isEqual/rules';
import { MockArgs } from './mocks';
import { Modifiers } from './Modifiers';
import { DynamicValidator } from './plugins/types';
import { Newable } from './types';
import { ValidatorsFor } from './validators/types';
export interface ExpectationOptions {
    extraMessage?: string;
}
export declare type Expectation<T> = Modifiers<T> & ValidatorsFor<T>;
/**
 * @internal
 */
export declare class __ExpectationImplementation<T> implements Modifiers<T> {
    private readonly actual;
    private readonly isNegated;
    private readonly options;
    private constructor();
    static make<T>(actual: T, isNegated?: boolean, options?: ExpectationOptions): Expectation<T>;
    get not(): Expectation<T>;
    toEqual(value: ExpectedEqual<T>): void;
    toLooseEqual(value: any): void;
    toReferentiallyEqual(value: number): void;
    toThrow(): void;
    toThrow(message: string): void;
    toThrow(errorClass: Newable<Error>, message?: string): void;
    toBeRejected(): Promise<void>;
    toBeRejected(message: string): Promise<void>;
    toBeRejected(errorClass: Newable<Error>, message?: string): Promise<void>;
    toBeA(clazz: any): void;
    toBeAContainerWith(...expectedItems: any[]): void;
    toBeAnArrayOfLength(length: number): void;
    toBeAnArrayWith(...expectedItems: ReadonlyArray<any>): void;
    toBeAnObjectWith(subset: Object): void;
    toBeGreaterThan(target: number): void;
    toBeGreaterThanOrEqualTo(target: number): void;
    toBeLessThan(target: number): void;
    toBeLessThanOrEqualTo(target: number): void;
    toBeTruthy(): void;
    toBeFalsy(): void;
    toBeDefined(): void;
    toBeNullish(): void;
    toBeExhausted(): void;
    toHaveBeenCalledWith(args: MockArgs<T>): void;
    toHaveBeenCalledExactlyWith(args: MockArgs<T>[]): void;
    toMatchSnapshot(): void;
    private getControl;
}
export declare function loadValidators(validators: Record<string, DynamicValidator<any>>): void;
export declare function getControl<T>(expectation: Expectation<T>): Control<T>;
