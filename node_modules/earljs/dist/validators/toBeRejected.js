"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toBeRejected = void 0;
const format_1 = require("../format");
const isEqual_1 = require("../isEqual");
const matchers_1 = require("../matchers");
function toBeRejected(control, expected) {
    return __awaiter(this, void 0, void 0, function* () {
        let actualRejectedValue;
        let rejectedAnything = false;
        try {
            yield control.actual;
        }
        catch (e) {
            rejectedAnything = true;
            actualRejectedValue = e;
        }
        // we need special handling for this case otherwise we end up with really dummy error message
        if (!rejectedAnything) {
            return control.assert({
                success: false,
                reason: `Expected to be rejected but didn't`,
                negatedReason: '-',
            });
        }
        const actualFmt = (0, format_1.formatCompact)(actualRejectedValue);
        const expectedFmt = expected instanceof matchers_1.AnythingMatcher
            ? 'anything'
            : expected instanceof matchers_1.ErrorMatcher
                ? expected.format()
                : (0, format_1.formatCompact)(expected);
        const reason = `Expected to be rejected with ${expectedFmt} but got ${actualFmt}`;
        const negatedReason = `Expected not to be rejected with ${expectedFmt} but was rejected with ${actualFmt}`;
        if (!(0, isEqual_1.isEqual)(actualRejectedValue, expected)) {
            control.assert({
                success: false,
                reason,
                negatedReason,
                actual: (0, format_1.format)(actualRejectedValue, null),
                expected: (0, format_1.format)(expected, actualRejectedValue),
            });
        }
        else {
            control.assert({
                success: true,
                reason,
                negatedReason,
                actual: (0, format_1.format)(actualRejectedValue, null),
                expected: (0, format_1.format)(expected, actualRejectedValue),
            });
        }
    });
}
exports.toBeRejected = toBeRejected;
